% Diese Zeile bitte -nicht- aendern.
\documentclass[course=erap]{aspdoc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TODO: Ersetzen Sie in den folgenden Zeilen die entsprechenden -Texte-
%% mit den richtigen Werten.
\newcommand{\theGroup}{196} % Beispiel: 42
\newcommand{\theNumber}{A328} % Beispiel: A123
\author{⁨Aleksandre Kandelaki \and Matthias Staritz \and Benjamin Liertz}
\date{Sommersemester 2020/21} % Beispiel: Wintersemester 2019/20
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Diese Zeile bitte -nicht- aendern.
\title{Gruppe \theGroup{} -- Abgabe zu Aufgabe \theNumber}

\begin{document}
\maketitle

\section{Einleitung}


Im Folgenden wird im Rahmen der Projektarbeit im Fach Einführung
in die Rechnerarchitektur an der TU München ein in linearer Algebra häufig 
benutztes Verfahren genauer beschrieben, implementiert und enstprechend dokumentiert.\\

\noindent\hspace*{15mm}%
Das Verfahren LU-Zerlegung, auch LR-Zerlegung genannt,
 bietet eine Möglichkeit per Algorithmus lineare Gleichungssysteme zu lösen und Matrixinverse zu bestimmen.
Dazu liefert die LU-Zerlegung für jedes eindeutig
 lösbare Gleichungssystem, also wenn A regulär ist,
  zwei Dreiecksmatrizen L und U und eine Pivot-Matrix P,
   wobei P*L*U = A ergibt. Hierbei haben die Matrizen besondere 
   Eigenschaften. L hat in allen Einträgen oberhalb der Diagonalen die Werte 0 und liefert 
   Auskunft über die Verwendeten Zeilenoperationen. U hingegen hat in allen Einträgen unterhalb
    der Diagonalen die Werte 0 und bildet somit eine Zeilenstufenform des LGS von der sich die 
    Lösungsmenge einfach ableiten lässt. Die Matrix P ist im eine Einheitsmatrix mit ggf. 
    vertauschten Zeilen mit der die Vertauschung von Zeilen nachvollziehbar wird.
    

\noindent\hspace*{15mm}%
Ein anschauliches Beispiel hierzu wäre das lineare Gleichungssystem:
\begin{eqnarray}
0x_1 + 3x_2 + 5x_3 + 7x_4 = 0 \\
2x_1 + 6x_2 + 10x_3 + 14x_4 = 0\\
-4x_1 + 12x_2 + 15x_3 + -21x_4 = 0\\
6x_1 + 9x_2 + -5x_3 + -7x_4 = 0
\end{eqnarray}



\noindent\hspace*{15mm}%
Welches auch so dargestellt werden kann:
\begin{equation}
A = \begin{bmatrix}
 0	& 3	 & 5  & 7 \\
 2	& 6	 & 10 & 14 \\
-4	& 12 & 15 & -21\\
 6	& 9  & -5 & -7\\
 \end{bmatrix}
\end{equation}


\noindent\hspace*{15mm}%
Nach Anwendung der LU-Zerlegung ergeben sich folgende Matrizen:
 \begin{equation}

 A = \begin{bmatrix}
 0	& 3	 & 5  & 7 \\
 2	& 6	 & 10 & 14 \\
-4	& 12 & 15 & -21\\
 6	& 9  & -5 & -7\\
 \end{bmatrix}
  L =
 \begin{bmatrix}
 1	& 0	 & 0  & 0 \\
 0	& 1	 & 0 & 0 \\
-2	& 8 & 1 & 0\\
 3	& -3  & 4 & 1\\
 \end{bmatrix}
 U =
\begin{bmatrix}
 2	& 6	 & 10 & 14 \\
 0	& 3	 & 5 &  7 \\
 0	& 0  & -5 & -49\\
 0	& 0  & 0 &  168\\
 \end{bmatrix}
 P =
 \begin{bmatrix}
 0	& 1	 & 0 & 0 \\
 1	& 0	 & 0 & 0 \\
 0	& 0  & 1 & 0\\
 0	& 0  & 0 & 1\\
 \end{bmatrix}
 \end{equation}
 
 



\section{Lösungsansatz}
Zur Durchführung diser Zerlegung haben wir uns entschieden eine Programm auf Basis des gaußschen Eliminationsverfahren zu enwickeln.
 Das gaußsche Eliminationsverfahren auf einer Matrix verwendet elementare Zeilenoperationen, wie das Tauschen zweier Zeilen oder das Addieren von vielfachen einer Zeile auf eine andere
 um die Einträge der Matrix zu ändern. Dabei wird das Gleichungssystem A*x = b verändert die Lösung bleibt aber erhalten.\\
\noindent\hspace*{15mm}%
Unter Verwendung dieses Verfahrens erstellen wir eine obere Dreieckmatrix bei der alle Einträge unter der 
diagonalen 0 sind. So erhalten wir unsere U Matrix. Um nun auch unsere L und P Matrizen zu erhalten, müssen
wir nur alle Schritte die zur Generierung der U matrix beigetragen haben Dokumentieren. Jedes mal wenn wir eine Zeile auf eine andere addieren
wird dies in der L Matrix festgehalten indem genau die selbe Operation auf dieser L Matrix durchgeführt wird. Jede Zeilenvertauschung Wird auf die selbe Art in P festgehalten(siehe Grafik 6).  
Um nun sicher eine gültige L Matrix zu erhalten welche oberhalb der Diagonalen nur die 0 als Einträge hat, folgt der Algorithmus strikt der Vorgehensweise des Gauß Algorithmus.\\
\noindent\hspace*{15mm}%
 Gehen wir davon aus das wir für jede der Matrizen L, U und P einen Speicherplatz haben.
Zu beginn müssen die passenden Startwerte In diesen Matrizen abgelegt werden. In L und P sind das einfach Einheitsmatrizen und in L wird die Eingabematrix A geschriben. Nun Werden die Eintäge unterhalb der Diagonalen in U  
Spaltenweise von Links nach Rechts auf 0 gesetzt indem man immer ein genau passendes vielfaches einer oberen Zeile von allen darunterliegenden 
Zeilen abzieht.(?? Grafik Einfügen ??) Die Wahl der Zeile hängt davon ab welche Spalte gerade auf 0 gesetzt werden soll. 
Bei Spalte 1 ist es Zeile 1 bei Spalte 2 Zeile 2 und so weiter. Da man sich hierbei von oben nach unten bwz. von links nach rechts Vorarbeitet generiert man schrittweise
die gewünschte L und U Matrix. Nun kann es aber vorkommen dass in der Zeile welche von den anderen Zeilen subtrahiert werden soll an dem Index der zu bearbeitenden
Spalte eine 0 steht. Dies birgt das Problem dass nun kein vielfaches dieser Zeile jehmals die anderen Einträge der Spalte durch subtraktion auf 0 bringen kann
da $ 0 \times x = 0$. Um dieses Problem zu vermeiden haben wir uns entschieden generell, bevor wir mit der Nullung einer Zeile beginnen immer die Zeile mit dem größsten Eintrag
am entsprechenden Index nach oben zu Tauschen(Siehe Grafik). Dadurch wird Garantiert dass der Algorithmus bei einer regulären, quadratischen Matrix erfolgreich durchläuft. Im Abschnitt zur Genauigkeit wird noch genau darauf 
eingegeangen warum wir immer die Zeile mit dem größten Eintrag nach oben tauschen und nicht bloß Irgend eine Zeile mit Eintrag ungleich 0.
Hierbei sei gesagt dass nicht jede Matrixzerlegung Zeilenvertauschungen benötigt und das der Algorithmus auf diese Art oft unnötige Vertauschungen durchführt was potential für 
optimierungen bietet.\\\\
 

 (GRafik für vertauschungen und addierungen mit notierung in P und L mit referenz im text)\\\\
\noindent\hspace*{15mm}% 
 Wie man sieht erhält man mit diesem Algorithmus in L eine untere Dreiecksmatrix in U eine obere Dreieckmarix 
 und gegebenpalls in P eine Einheitsmatrix mit Zeilenvertauschungen\\\\

\subsection{Stack vs. Heap}
 Bei der Implementierung noch eine Weitere Gegebenheit Bearchtet werden.
 Undzwar wird bei Linux Betriebssystemen meistens circa 8MB Speicherplatz fuer die Stackallokationen zur verfuegung gestellt. Da wir auf Grund der besseren Zugriffszeiten des Stacks \cite{stack} gegenüber dem Heap den Stack so lange wie möglich verwenden wollen
  muss in unserem code eine Fallunterscheidung Implementiert werden welche jeh nach größe der Eingabe die Matrizen auf dem Stack oder auf dem Heap Allozieren.
 Die maximalgröße einer Eingabe welche noch auf dem Stack alloziert werden kann berechnen wir folgender maßen:
 Die größe unserer Eingabematrix A muss 4 mal alloziert werden da temporär A, L, U und P abgespeichert werdem müssen.
 Der in der Methode übergebene Parameter n ist die Anzahl Zeilen / Spalten unseren Matrix. Wodurch sich eine Anzahl Einträge pro Matrix von $n * n $ ergibt. 
 Jeder dieser Einträge ist in unserem Fall ein Floating Point Wert und somit 4 Bytes groß.
 Daraus ergibt sich die Formel \ref{size} Welche die benötigte Anzahl bytes in Abhängigkeit unserer Eingabegröße n Berechnet.
 
 \begin{equation}
 \label{size}
  #bytes = 4*4*n*n
 \end{equation}
Daraus folgt dass unser $n$ für eine nutzung des Stacks  $n <= 707$  sein muss.\ref{maxsize}
 \begin{equation}
 \label{maxsize}
  4*4*n*n <= 8*10^6
 \end{equation}
 Um etwas Spielraum zu haben haben wir uns entschieden schon ab einem $n >= 700$ auf dem Heap zu allozieren.\\\\\\


\subsection{Verschiedene Implementierungen}
Wie eben schon erwähnt ist uns aufgefallen dass die LU Zerlegung vieler Matrizen immer noch gelöst werden kann wenn man die Pivotisierung weg lässt. In der Theorie könnte man dadurch einen Performance Gewinn erbringen. 
Um dies zu überprüfen haben wir eine Vergleichsimplementierung in erstellt welche pivotisierungen nicht berücksichtigt. Abgesehen davon ist diese Implementierung aber Analog zu obigen Ansatz.
Abgesehen davon haben wir Verschiedene Implementierungen des genannten Ansatzes Erstellt auf die unter Performance noch genauer eingegangen wird.


% TODO: Je nach Aufgabenstellung einen der Begriffe wählen
\section{Genauigkeit}
- 

\section{Performanzanalyse}
In unserer Performanceanalyse vergleichen wir folgende Implementierungen:\\
\begin{itemize}
\item Lineare C Implementierung ohne Compileroptimierung und mit Pivotisierung vs. Lineare C implementierung ohne Compileroptimierung und ohne Pivotisierung. 
\item Lineare C Implementierung ohne Compileroptimierung vs. C Implementierung mit Vektorisierung durch Intrinsics. 
\item Lineare C Implementierung mit Compileroptimierung -O3 vs. Assembler Implementierung mit SIMD Vektorisierung.
\end{itemize}
Die Ergebnisse der Vergleiche werden in den folgenden Unterkapiteln ausgeführt.

\subsection{Pivotisierung vs. keine Pivotisierung}
Leider ist der Perfomace Gewinn wie man an Grafik* unschwer erkennen Kann wenn überhaut bloß maginal. Dies liegt an\ldots
\subsection{Linear vs. Parallel durch Intrinsics}
Mit Hilfe von perf tool haben wir unsere C Implementierung auf die Performanz getestet und festgestellt , dass die Meiste Zeit in einem bestimmten Loop verbracht wird.
 Wir haben versucht den Abschnitt mit C intrinsics zu vektorisieren, was auch geklappt hat. Das hatte eine positive Auswirkung fuer die Laufzeit der Zerlegung was auch in diesem Graph zu sehen ist.\\\\
 \begin{figure}[t]
 \centering
 \includegraphics[width = 0.8\linewidth]{cvsintrinsics.png}
 \label{CvsIntrinsics}
\end{figure}

 \subsection{Compiler optimierter Code vs. ASM mit SIMD}

Wie gut sind wir an der Performanze des Compilers




\section{Zusammenfassung und Ausblick}
Welche Performance war jetzt am besten?\\
Rückblickend hätte man ohne pivotisierung weglassen können\\
% TODO: Fuegen Sie Ihre Quellen der Datei Ausarbeitung.bib hinzu
% Referenzieren Sie diese dann mit \cite{}.
% Beispiel: CR2 ist ein Register der x86-Architektur~\cite{intel2017man}.
\bibliographystyle{plain}
\bibliography{Ausarbeitung}{}

\end{document}

